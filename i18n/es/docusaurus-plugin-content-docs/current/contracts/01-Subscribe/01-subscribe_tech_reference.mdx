---
id: subscribe_tech_reference
title: Referencia Técnica
---

# ClockTower Subscribe

### Rangos de Tiempo

- Suscripciones Semanales -- 1 - 7 (Días de la semana)
- Suscripciones Mensuales -- 1 - 28 (Día del mes)
- Suscripciones Trimestrales -- 1 - 90 (Día del trimestre)
- Suscripción Anual -- 1 - 365 (Día del año (sin incluir días bisiestos))

### Decimales
Todos los valores ERC20 se almacenan en el contrato como 18 decimales y se convierten antes de interactuar con los contratos de tokens.

## Estructuras de Datos
Las siguientes son las estructuras de datos requeridas o devueltas por funciones externas:

### Estructuras

##### Subscription

```
 struct Subscription {
    bytes32 id;
    uint amount;
    address provider;
    address token;
    bool exists;
    bool cancelled;
    Frequency frequency;
    uint16 dueDay;
    string description;
}
```
| Nombre | Tipo | Descripción|
|---|---|---|
| `id` | bytes32 | Hash único generado para cada suscripción |
| `amount` | uint | Cantidad de la suscripción en wei (18 decimales) |
| `provider` | address | Dirección del creador de la suscripción |
| `token` | address | Dirección ERC20 del token usado en la suscripción |
| `cancelled` | bool | Verdadero si la suscripción está cancelada |
| `frequency` | Frequency | [Frequency](#frequency) |
| `dueDay` | uint16 | Día en el rango de [frecuencia](#rangos-de-tiempo) cuando se paga la suscripción |


##### SubView
```
 struct SubView {
    Subscription subscription;
    Status status;
    uint totalSubscribers;
 }
```
| Nombre | Tipo | Descripción|
|---|---|---|
| `subscription` | Subscription | [Subscription](#subscription) |
| `status` | Status | [Status](#status) |
| `totalsubscribers` | uint | Número total de suscriptores |

##### FeeEstimate
```
struct FeeEstimate {
    uint fee;
    address token;
}
```
| Nombre | Tipo | Descripción|
|---|---|---|
| `fee` | uint | Cantidad de tarifa en wei (18 decimales) |
| `token` | address | Dirección ERC20 del token |

##### SubscriberView
```
struct SubscriberView {
    address subscriber;
    uint feeBalance;
}
```
| Nombre | Tipo | Descripción|
|---|---|---|
| `subscriber` | address | Dirección del suscriptor |
| `feeBalance` | uint | Saldo de tarifa del suscriptor en wei |

##### Time
```
struct Time {
    uint16 day;
    uint16 weekDay;
    uint16 quarterDay;
    uint16 yearDay;
    uint16 year;
    uint16 month;
}
```
| Nombre | Tipo | Descripción|
|---|---|---|
| `day` | uint16 | Día del mes |
| `weekDay` | uint16 | Día de la semana |
| `quarterDay` | uint16 | Día del trimestre |
| `yearDay` | uint16 | Día del año |
| `year` | uint16 | Año |
| `month` | uint16 | Mes |


### Enums
(Los valores de enum se representan por números que comienzan en cero)

##### Frequency
```
enum Frequency {
    WEEKLY,
    MONTHLY,
    QUARTERLY,
    YEARLY
}
```
| Valor | Descripción|
|---|---|
| `0` | WEEKLY |
| `1` | MONTHLY |
| `2` | QUARTERLY |
| `3` | YEARLY |

##### Status
```
enum Status {
    ACTIVE,
    CANCELLED,
    UNSUBSCRIBED
}
```
| Valor | Descripción|
|---|---|
| `0` | ACTIVE |
| `1` | CANCELLED |
| `2` | UNSUBSCRIBED |

##### SubEvent
```
enum SubEvent {
    PAID,
    FAILED,
    SUBSCRIBED, 
    UNSUBSCRIBED,
    FEEFILL, 
    REFUND
}
```
| Value | Description|
|---|---|
| `0` | PAID |
| `1` | FAILED |
| `2` | SUBSCRIBED |
| `3` | UNSUBSCRIBED |
| `4` | FEEFILL |
| `5` | REFUND |

##### ProvEvent
```
enum ProvEvent {
    CREATE,
    CANCEL,
    PAID,
    FAILED,
    REFUND
}
```
| Value | Description|
|---|---|
| `0` | CREATE |
| `1` | CANCEL |
| `2` | PAID |
| `3` | FAILED |
| `4` | REFUND |


## Variables Globales

| Nombre | Tipo | Descripción| Formato |
|---|---|---|---|
| `callerFee` | uint | Porcentaje de suscripciones pagadas al llamador en remesas | 10000 = Sin tarifa, 10100 = 1%, 10001 = 0.01% |
| `systemFee` | uint | Porcentaje de tarifa del llamador pagado al sistema cuando systemFee bool es verdadero | 10000 = Sin tarifa, 10100 = 1%, 10001 = 0.01% |
| `maxRemits` | uint | Número máximo de remesas por función remit (generalmente basado en el máximo del bloque) | |
| `admin` | address | Dirección de la cuenta de administrador |
| `nextUncheckedDay` | uint40 | Índice del día del día que no ha sido remitido | Índice del día |

## Eventos
##### SubscriberLog
```
event SubscriberLog(
    bytes32 indexed id,
    address indexed subscriber,
    uint40 timestamp,
    uint amount,
    SubEvent indexed subEvent
)
```

Registro emitido durante eventos de suscriptor

| Nombre | Tipo | Indexado | Descripción |
|---|---|:---:|---|
| `id` | bytes32 | :heavy_check_mark: | ID único de suscripción |
| `subscriber` | address | :heavy_check_mark: | Dirección del suscriptor |
| `timestamp` | uint40 | | Marca de tiempo Unix Epoch |
| `amount` | uint | | Cantidad de suscripción ERC20 en wei (18 decimales) |
| `subEvent` | SubEvent | :heavy_check_mark: | [SubEvent](#subevent)

##### CallerLog
```
event CallerLog(
    uint40 timestamp,
    uint40 checkedDay,
    address indexed caller,
    bool isFinished
)
```

Registro emitido durante eventos del Llamador

| Nombre | Tipo | Indexado | Descripción |
|---|---|:---:|---|
| `timestamp` | uint40 | | Marca de tiempo Unix epoch |
| `checkedDay` | uint40 | | Día en el rango de frecuencia verificado por el Llamador |
| `caller` | address | :heavy_check_mark: | Dirección del llamador |
| `isFinished` | bool | | Muestra si el Llamador ha terminado |

##### ProviderLog
```
event ProviderLog(
    bytes32 indexed id,
    address indexed provider,
    uint40 timestamp,
    uint amount,
    ProvEvent indexed provEvent
)
```

Registro emitido durante eventos del Proveedor

| Nombre | Tipo | Indexado | Descripción |
|---|---|:---:|---|
| `id` | bytes32 | :heavy_check_mark: | ID único de suscripción |
| `provider` | address | :heavy_check_mark: | Dirección del proveedor |
| `timestamp` | uint40 | | Marca de tiempo Unix epoch |
| `amount` | uint | | 0 a menos que sea reembolso |
| `provEvent` | ProvEvent | :heavy_check_mark: | [ProvEvent](#provevent) |


## Funciones
### Funciones de Suscripción
##### createSubscription
```
function createSubscription(
    uint amount,
    address token, 
    string description, 
    Frequency frequency, 
    uint16 dueDay
) external payable
```
Permite al proveedor crear una nueva suscripción. 

Parámetros:

| Nombre | Tipo | Descripción |
|---|---|---|
| `amount` | uint | Cantidad de la suscripción en wei. (DEBE ESTAR EN 18 DECIMALES) |
| `token` | address | Dirección ERC20 del token usado en la suscripción |
| `description` | string | Descripción de la suscripción |
| `frequency` | Frequency | [Frequency](#frequency) |
| `dueDay` | uint16 | Día en el [rango](#rangos-de-tiempo) basado en la frecuencia cuando se paga la suscripción |

##### subscribe
```
function subscribe(
    Subscription subscription
) external payable
```
Permite al usuario suscribirse a la suscripción

Parámetros: 

| Nombre | Tipo | Descripción |
|---|---|---|
| `subscription` | Subscription | [Subscription](#subscription) |


##### unsubscribe
```
function unsubscribe(
    bytes32 id
) external payable
```
Permite al usuario cancelar la suscripción. 

msg.sender debe estar suscrito a la suscripción. 

Parámetros:

| Nombre | Tipo | Descripción |
|---|---|---|
| `id` | bytes32 | ID único de suscripción |

##### unsubscribeByProvider
```
function unsubscribeByProvider(
    address subscriber, 
    bytes32 id
) external
```
Permite al proveedor cancelar al suscriptor de sus suscripciones creadas. 

msg.sender debe ser el creador de la suscripción y el suscriptor debe estar suscrito. 

Parámetros: 

| Nombre | Tipo | Descripción |
|---|---|---|
| `subscriber` | address | Dirección del suscriptor |
| `id` | bytes32 | ID único de suscripción |


##### cancelSubscription
```
function cancelSubscription(
    Subscription subscription
) external
```
Permite al proveedor cancelar la suscripción. Todos los suscriptores existentes ya no serán cobrados

msg.sender debe ser el creador de la suscripción

Parámetros: 

| Nombre | Tipo | Descripción |
|---|---|---|
| `subscription` | Subscription | [Subscription](#subscription) |


### Funciones de Vista
##### getAccountSubscriptions
```
function getAccountSubscriptions(
    bool bySubscriber,
    address account
    ) returns (SubView[])
```
Devuelve un array de objetos que contienen suscripción y estado por cuenta. 

Si bySubscriber es verdadero, obtiene una lista de suscripciones a las que la cuenta está suscrita. 
Si es falso, obtiene una lista de suscripciones que la cuenta creó como proveedor. 

Parámetros: 

| Nombre | Tipo | Descripción |
|---|---|---|
| `bySubscriber` | bool | Ver descripción anterior del bool |
| `account` | address | Dirección de la cuenta para suscripciones | 

Valor de Retorno:

| Nombre | Tipo | Descripción |
|---|---|---|
| `SubView[]` | SubView | Array de estructuras [Subview](#subview) |

##### getTotalSubscribers
```
function getTotalSubscribers(
    ) returns (uint)
```

Devuelve el número total de suscriptores.

Valor de Retorno:

| Nombre | Tipo | Descripción |
|---|---|---|
| `uint` | uint | Cantidad total de suscriptores en el contrato |

##### getSubscribersById
```
function getSubscribersById(
    bytes32 id
    ) external view returns (SubscriberView[] memory)
```

Devuelve un array de objetos que contienen información del suscriptor. 

Parámetros: 

| Nombre | Tipo | Descripción |
|---|---|---|
| `id` | bytes32 | ID único de suscripción |

Valor de Retorno:

| Nombre | Tipo | Descripción |
|---|---|---|
| `SubscriberView[]` | SubscriberView | Array de estructuras [SubscriberView](#subscriberview) |

##### getSubByIndex
```
function getSubByIndex(
    bytes32 id, 
    Frequency frequency, 
    uint16 dueDay
    ) view public returns(Subscription subscription)
```

Devuelve el objeto de suscripción

Parámetros: 

| Nombre | Tipo | Descripción |
|---|---|---|
| `id` | bytes32 | ID único de suscripción |
| `frequency` | Frequency | [Frequency](#frequency) |
| `dueDay` | uint16 | Día en el [rango](#rangos-de-tiempo) basado en la frecuencia cuando se paga la suscripción |

Valor de Retorno:

| Nombre | Tipo | Descripción |
|---|---|---|
| `subscription` | Subscription | [Subscription](#subscription) |


##### feeEstimate
```
function feeEstimate(

) returns(FeeEstimate[]) 
```
Devuelve un array de objetos que muestran el siguiente lote de remesas y tarifas posibles

Valor de Retorno:

| Nombre | Tipo | Descripción |
|---|---|---|
| `FeeEstimate[]` | FeeEstimate | Array de estructuras [FeeEstimate](#feeestimate) |

### Funciones de Tiempo

##### unixToTime
```
function unixToTime(
    uint unix
) returns(Time time)
```
Convierte un valor de tiempo unix a la estructura [Time](#time)

Parámetro:

| Nombre | Tipo | Descripción |
|---|---|---|
| `unix` | uint | Valor de tiempo unix |

Valor de Retorno:

| Nombre | Tipo | Descripción |
|---|---|---|
| `time` | Time | Estructura [Time](#time) |

Code:

```
uint _days = unix/86400;
uint16 day;
uint16 yearDay;
       
int __days = int(_days);

int L = __days + 68569 + 2440588;
int N = 4 * L / 146097;
L = L - (146097 * N + 3) / 4;
int _year = 4000 * (L + 1) / 1461001;
L = L - 1461 * _year / 4 + 31;
int _month = 80 * L / 2447;
int _day = L - 2447 * _month / 80;
L = _month / 11;
_month = _month + 2 - 12 * L;
_year = 100 * (N - 49) + _year + L;

uint uintyear = uint(_year);
uint month = uint(_month);
uint uintday = uint(_day);

day = uint16(uintday);        

uint dayCounter;

//loops through months to get current day of year
for(uint monthCounter = 1; monthCounter <= month; monthCounter++) {
    if(monthCounter == month) {
        dayCounter += day;
    } else {
        dayCounter += getDaysInMonth(uintyear, month);
    }
}

    yearDay = uint16(dayCounter);

    //gets day of quarter
    time.quarterDay = getdayOfQuarter(yearDay, uintyear);
    time.weekDay = getDayOfWeek(unix);
    time.day = day;
    time.yearDay = yearDay;
```

##### isLeapYear
```
function isLeapYear(
    uint year
) returns (bool leapYear)
```

Verifica si el año es bisiesto

Parámetro:

| Nombre | Tipo | Descripción |
|---|---|---|
| `year` | uint | Número del año en el Calendario Gregoriano |

Valor de Retorno:

| Nombre | Tipo | Descripción |
|---|---|---|
| `leapYear` | bool | Verdadero si es año bisiesto |

Code:

```
leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
```

##### getDaysInMonth
```
function getDaysInMonth(
    uint year, 
    uint month
) returns (uint daysInMonth)
```
Devuelve el número de días en el mes basado en los valores del calendario gregoriano de año y mes

Parámetros:

| Nombre | Tipo | Descripción |
|---|---|---|
| `year` | uint | Número del año en el Calendario Gregoriano |
| `month`| uint | Número del mes en el Calendario Gregoriano |

Valor de Retorno:

| Nombre | Tipo | Descripción |
|---|---|---|
| `daysInMonth` | uint | Número de días en el mes |

Code: 

```
if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
    daysInMonth = 31;
} else if (month != 2) {
    daysInMonth = 30;
} else {
    daysInMonth = isLeapYear(year) ? 29 : 28;
}
```

##### getDaysOfWeek
```
function getDaysofWeek(
    uint unixTime
) returns (uint16 dayOfWeek)
```

Devuelve el número del día de la semana

Parámetro:

| Nombre | Tipo | Descripción |
|---|---|---|
| `unixTime` | uint | Valor de tiempo unix |

Valor de Retorno:

| Nombre | Tipo | Descripción |
|---|---|---|
| `dayOfWeek` | uint16 | Día de la semana (1 = Lunes, 7 = Domingo) |

Code:

```
uint _days = unixTime / 86400;
uint dayOfWeekuint = (_days + 3) % 7 + 1;
dayOfWeek = uint16(dayOfWeekuint);
```

##### getdayOfQuarter
```
function getdayOfQuarter(
    uint yearDays, 
    uint year
) returns (uint16 quarterDay)
```

Devuelve el día del rango del trimestre basado en el año y el día del año

Parámetros:

| Nombre | Tipo | Descripción |
|---|---|---|
| `yearDays` | uint | Día del año (Entre 1 - 365) |
| `year`| uint | Número del año en el Calendario Gregoriano |

Valor de Retorno:

| Nombre | Tipo | Descripción |
|---|---|---|
| `quarterDay` | uint16 | Día del trimestre (1 - 90) |

Code:
```
uint leapDay;
if(isLeapYear(year)) {
    leapDay = 1;
} else {
    leapDay = 0;
}

if(yearDays <= (90 + leapDay)) {
    quarterDay = uint16(yearDays);
} else if((90 + leapDay) < yearDays && yearDays <= (181 + leapDay)) {
    quarterDay = uint16(yearDays - (90 + leapDay));
} else if((181 + leapDay) < yearDays && yearDays <= (273 + leapDay)) {
    quarterDay = uint16(yearDays - (181 + leapDay));
} else {
    quarterDay = uint16(yearDays - (273 + leapDay));
}
```

##### unixToDays
```
function unixToDays (
    uint40 unixTime
) returns (uint40 dayCount)
```

Devuelve la cantidad de días (redondeado hacia abajo) desde la época unix basado en un tiempo unix proporcionado

Parámetro:

| Nombre | Tipo | Descripción |
|---|---|---|
| `unixTime` | uint | Valor de tiempo unix |

Valor de Retorno:

| Nombre | Tipo | Descripción |
|---|---|---|
| `dayCount` | uint16 | Número de días (redondeado hacia abajo) desde la época unix |

Code:

```
dayCount = unixTime/86400;
```

##### prorate
```
function prorate (
    uint unixTime, 
    uint40 dueDay, 
    uint fee, 
    uint8 frequency) returns (uint) 
```

Devuelve la cantidad prorrateada de la suscripción basada en los parámetros de suscripción

Parámetros:

| Nombre | Tipo | Descripción |
|---|---|---|
| `unixTime` | uint | Valor de tiempo unix |
| `dueDay` | uint40 | Día en el rango de [frecuencia](#rangos-de-tiempo) cuando se paga la suscripción |
| `fee` | uint | Cantidad de tarifa en wei (18 decimales) |
| `frequency` | uint8 | [Frequency](#frequency) |

Valor de Retorno:

| Nombre | Tipo | Descripción |
|---|---|---|
| `uint` | uint | Cantidad prorrateada de la suscripción en wei (18 decimales) |

Code: 

```
Time memory time = unixToTime(unixTime);
uint currentDay;
uint max;
uint lastDayOfMonth;
        
//sets maximum range day amount
if(frequency == 0) {
    currentDay = time.weekDay;
    max = 7;
//monthly
} else if (frequency == 1){
    //calculates maximum days in current month
    lastDayOfMonth = getDaysInMonth(time.year, time.month);
    currentDay = time.dayOfMonth;
    max = lastDayOfMonth;
//quarterly and yearly
} else if (frequency == 2) {
    currentDay = getdayOfQuarter(time.yearDay, time.year);
    max = 90;
//yearly
} else if (frequency == 3) {
    currentDay = time.yearDay;
    max = 365;
}

//monthly
if(frequency == 1) {
    uint dailyFee = (fee * 12 / 365);
    if(dueDay != currentDay && currentDay > dueDay){
        //dates split months
        fee = (dailyFee * (max - (currentDay - dueDay)));
    } else if (dueDay != currentDay && currentDay < dueDay) {
        //both dates are in the same month
        fee = (dailyFee * (dueDay - currentDay));
    }
}
//weekly quarterly and yearly
else if(frequency == 0 || frequency == 2 || frequency == 3) {
    if(dueDay != currentDay && currentDay > dueDay){
        fee = (fee / max) * (max - (currentDay - dueDay));
    } else if (dueDay != currentDay && currentDay < dueDay) {
        fee = (fee / max) * (dueDay - currentDay);
    }
}  
       
return fee;
```