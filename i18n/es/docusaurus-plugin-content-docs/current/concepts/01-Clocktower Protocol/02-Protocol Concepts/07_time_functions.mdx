---
id: time_functions
title: Funciones de Tiempo
sidebar_position: 7
---

## Tiempo

La comprensión computacional y humana del tiempo es crítica para el Protocolo Clocktower. Para que el contrato pueda programar transacciones en el futuro, debe saber qué hora es. Logramos esto incentivando al llamador para que consulte el contrato de manera regular.

Para programar realmente las transacciones, debemos traducir la comprensión del tiempo de diferentes seres humanos en algo que el contrato pueda reconocer y guardar.

Pero primero una digresión sobre los fundamentos del tiempo.

### Dos Sistemas de Tiempo

Nuestros sistemas de tiempo son formas para que los humanos capturen ocurrencias naturales regulares. Los años representan cuánto tiempo tarda la tierra en moverse alrededor del sol, los días cuánto tiempo tarda la tierra en girar completamente. Los segundos se traducen aproximadamente al ritmo de un latido del corazón y los meses al ciclo de la luna.

Si bien los humanos (y las computadoras) prefieren pensar en abstracciones en términos discretos, la naturaleza generalmente no es tan clara y seca. Por ejemplo, los años no se alinean perfectamente con 365 días y la rotación de la tierra se ralentiza ligeramente con el tiempo. Estas variaciones han llevado a la evolución de dos sistemas de tiempo distintos.

#### Tiempo Unix

Una de las formas más fáciles de medir el tiempo es elegir un punto arbitrario en el pasado e incrementar un número a intervalos regulares. En las computadoras, uno encuentra esto más a menudo en el [Tiempo Unix](https://en.wikipedia.org/wiki/Unix_time), que es un sistema donde un número se incrementa cada segundo después de la medianoche del 1 de enero de 1970.

##### Días Bisiestos y Segundos Bisiestos

El problema es que la naturaleza no se incrementa tan limpiamente. Para lidiar con los aspectos más analógicos y variables de la rotación cada vez más lenta de la tierra y los días fraccionarios del año, se debe agregar o restar tiempo al incremento para no desconectarse de la naturaleza.

Así, se agregan días bisiestos y segundos bisiestos para mantener las cosas sincronizadas.

#### Tiempo Gregoriano

Para lidiar con el problema de los días del año, la mayor parte del mundo usa el [Calendario Gregoriano](https://en.wikipedia.org/wiki/Gregorian_calendar) atribuido al [Papa Gregorio XIII](https://en.wikipedia.org/wiki/Pope_Gregory_XIII) y basado en una [versión anterior](https://en.wikipedia.org/wiki/Julian_calendar) diseñada por [Julio César](https://en.wikipedia.org/wiki/Julius_Caesar). El aspecto clave del calendario gregoriano es la adición de días bisiestos el 29 de febrero para sincronizar el calendario con la rotación solar de la tierra.

## Rangos de Tiempo

Las suscripciones son una serie temporal abierta. No puedes guardar fácilmente una serie abierta con un número incrementando. Por ejemplo, no hay una forma sensata de guardar la fecha "cada 5º día del mes" usando solo tiempo unix. Teóricamente podrías guardar una larga serie de fechas calculadas en segundos después de la medianoche del 1 de enero de 1970. Pero esto es ineficiente y ¿qué pasa si la suscripción dura más que la serie inicial de números? Ahora tienes que recalcular de alguna manera y agregar más. Una solución *mucho* más simple es usar un punto del calendario gregoriano.

Entonces, para cada tipo de frecuencia de suscripción, simplemente creamos un rango de números:

| Frecuencia | Rango |
|---|---|
| Semanal | 1 - 7 |
| Mensual | 1 - 28 |
| Trimestral | 1 - 90 |
| Anual | 1 - 365 |

Pero ahora nos hemos topado con un problema. ¿Cómo traducimos este número de rango de ida y vuelta al tiempo unix?

### Días Julianos

La mejor manera de traducir el número unix incrementando del timestamp del bloque a [rangos](time_functions#time-ranges) gregorianos es usar un estándar de día incrementando intermedio llamado [Días Julianos](https://en.wikipedia.org/wiki/Julian_day).

Usando el siguiente código, el contrato puede hacer esta traducción [sin Oráculos o cualquier otra fuente externa](goals#no-oracles)

Más detalles sobre estas funciones de traducción se pueden encontrar en la [documentación técnica](../../../contracts/01-Subscribe/01-subscribe_tech_reference.mdx)

### Problemas de Año Bisiesto

#### Días Bisiestos

Pero ¿qué pasa con nuestro incremento en presencia de un día bisiesto o segundo bisiesto? Los incrementos bisiestos en ciertas situaciones pueden causar problemas. Por ejemplo, si permites que el usuario configure una suscripción mensual para pagar el día 29 del mes, solo funcionará realmente cada cuatro años.

Es por eso que en los [rangos](time_functions#time-ranges) anteriores simplemente no permitimos que se use el día 29 del mes o superior en suscripciones mensuales o superior a 365 días en el rango anual.

#### Segundos Bisiestos

Los segundos bisiestos son menos preocupación para el protocolo por varias razones.

1. El timestamp en un bloque se calcula actualmente con una [varianza de quince segundos](https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/timestamp-dependence/) entre cuál es el tiempo real y el tiempo que un validador puede poner a un bloque. Estos quince segundos causan más deriva de lo que causaría un segundo bisiesto potencial.
2. La unidad de tiempo más pequeña usada en suscripciones es un día. Entonces, incluso si un timestamp es incorrecto, solo importaría si ocurriera a medianoche. Y esto solo le daría al llamador una ventaja para llamar al día siguiente si fueran un validador malicioso, lo cual es de baja probabilidad y solo adelantaría por unos segundos.
3. Al no permitir el día 29 del mes o superior o el día 366 del año, mitigamos que el timestamp derive el tiempo a un rango de día no permitido. 



